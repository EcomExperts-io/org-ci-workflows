name: Commit AI Review (Rules Only)

on:
  workflow_call:
    secrets:
      CHANNEL_ID:
        required: true
        description: "Slack channel ID to post the review"
      OPENAI_API_KEY:
        required: true
        description: "OpenAI API key"
      SLACK_BOT_TOKEN:
        required: true
        description: "Slack bot token with chat:write"

permissions:
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  review-latest-commit:
    runs-on: ubuntu-latest
    steps:
      - name: Guard caller org
        run: |
          if [ "${{ github.repository_owner }}" != "EcomExperts-io" ]; then
            echo "Unauthorized caller: ${{ github.repository_owner }}"
            exit 1
          fi

      - name: Checkout caller repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Gather commit data
        id: info
        run: |
          set -e
          SHA="${GITHUB_SHA}"
          REPO="${GITHUB_REPOSITORY}"
          ACTOR="${GITHUB_ACTOR}"
          echo "sha=$SHA" >> "$GITHUB_OUTPUT"
          echo "actor=$ACTOR" >> "$GITHUB_OUTPUT"
          echo "repo=$REPO" >> "$GITHUB_OUTPUT"
          # latest commit only
          git diff-tree --no-commit-id --name-status -r "$SHA" | tr -d '\r' > /tmp/changed.txt

      - name: Checkout central rules repo
        uses: actions/checkout@v4
        with:
          repository: EcomExperts-io/org-ci-workflows
          ref: Main
          path: rules-src
          fetch-depth: 1

      - name: Load rules from .cursor/rules
        id: rules
        run: |
          set -e
          PRIMARY_DIR="rules-src/.cursor/rules"
          FALLBACK_DIR="rules-src/cursor/rules"
          if [ -d "$PRIMARY_DIR" ]; then
            RULE_DIR="$PRIMARY_DIR"
          elif [ -d "$FALLBACK_DIR" ]; then
            RULE_DIR="$FALLBACK_DIR"
          else
            echo "No rules directory found. Expected $PRIMARY_DIR or $FALLBACK_DIR" >&2
            exit 1
          fi
          echo "rule_dir=$RULE_DIR" >> "$GITHUB_OUTPUT"

          jq -n '[]' > /tmp/rules.json
          while IFS= read -r -d '' file; do
            CONTENT=$(sed 's/\\/\\\\/g; s/"/\\"/g' "$file" | awk '{printf "%s\\n",$0}')
            
            # Extract metadata from frontmatter if it exists
            ALWAYS_APPLY="false"
            GLOBS=""
            if head -n 1 "$file" | grep -q "^---"; then
              # Parse frontmatter for alwaysApply and globs
              FRONTMATTER=$(sed -n '2,/^---/p' "$file" | sed '$d')
              if echo "$FRONTMATTER" | grep -q "alwaysApply: *true"; then
                ALWAYS_APPLY="true"
              fi
              GLOBS=$(echo "$FRONTMATTER" | grep "^globs:" | sed 's/globs: *//' | tr '\n' ',' | sed 's/,$//')
            fi
            
            jq --arg name "$(basename "$file")" \
               --arg path "$file" \
               --arg text "$CONTENT" \
               --arg always_apply "$ALWAYS_APPLY" \
               --arg globs "$GLOBS" \
               '. += [{"name":$name,"path":$path,"text":$text,"always_apply":($always_apply=="true"),"globs":$globs}]' \
               /tmp/rules.json > /tmp/rules.tmp && mv /tmp/rules.tmp /tmp/rules.json
          done < <(find "$RULE_DIR" -type f -maxdepth 5 -print0 | sort -z)

          # Build an index of allowed rule_ids (filenames without extension)
          jq -r '.[].name | sub("\\.mdc$"; "")' /tmp/rules.json | jq -R -s 'split("\n") | map(select(length>0))' > /tmp/rules_index.json

          echo "Loaded rules:"
          jq 'length as $n | "count=\($n)"' /tmp/rules.json
          echo "Rule names:"
          jq -r '.[]' /tmp/rules_index.json | head -50

      - name: Build numbered files bundle from latest commit only
        run: |
          set -e
          jq -n '{files:[]}' > /tmp/files.json
          while IFS=$'\t' read -r status path; do
            case "$path" in
              *.liquid|*.json|*.js|*.mjs|*.cjs|*.ts|*.tsx|*.jsx|*.css|*.scss|*.sass|*.vue|*.html|*.svg|*.yml|*.yaml|*.md|*.mdc)
                if [ -f "$path" ]; then
                  NUMBERED=$(nl -ba -w1 -s': ' "$path" | sed 's/\\/\\\\/g; s/"/\\"/g' | awk '{printf "%s\\n",$0}')
                  
                  # Determine applicable rules for this file
                  APPLICABLE_RULES=$(jq -c --arg filepath "$path" '
                    map(select(
                      .always_apply == true or
                      (.globs != "" and (
                        .globs | split(",") | map(gsub(" "; "")) | map(select(length > 0)) |
                        any(. as $glob | $filepath | test($glob | gsub("\\*"; ".*") | gsub("\\?"; ".")))
                      ))
                    )) | map(.name | sub("\\.mdc$"; ""))
                  ' /tmp/rules.json)
                  
                  jq --arg p "$path" --arg n "$NUMBERED" --argjson rules "$APPLICABLE_RULES" \
                     '.files += [{"path":$p,"numbered":$n,"applicable_rules":$rules}]' \
                     /tmp/files.json > /tmp/files.tmp && mv /tmp/files.tmp /tmp/files.json
                fi
              ;;
            esac
          done < /tmp/changed.txt

          echo "Changed files captured:"
          jq '.files | length as $n | "count=\($n)"' /tmp/files.json

      - name: Build AI input (rules only, no diff)
        run: |
          set -e
          RULES=$(cat /tmp/rules.json)
          FILES=$(cat /tmp/files.json)
          printf '{"rules":%s,"files":%s}' "$RULES" "$FILES" > /tmp/ai_input.json
          echo "ai_input.json sizes:"
          echo "rules.json bytes: $(wc -c < /tmp/rules.json)"
          echo "files.json bytes: $(wc -c < /tmp/files.json)"

      - name: Call OpenAI strictly by rules
        id: ai
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set -e
          REQ=$(jq -c -n \
            --arg content "$(cat /tmp/ai_input.json)" \
            '{
              model:"gpt-4o",
              response_format:{type:"json_object"},
              temperature:0,
              messages:[
                {
                  "role":"system",
                  "content": "You are a comprehensive code reviewer that evaluates files against coding standards. For each file, check ALL applicable rules from the rules[] array. Rules apply based on: 1) alwaysApply: true in metadata, or 2) file path matching globs patterns in metadata. Look for ALL violations of the provided rules - be thorough and comprehensive. For each violation found: use rule_id as the rule filename without .mdc extension (e.g., \"rules-of-enagagment\" not \"rules-of-enagagment.mdc\"), provide specific reason explaining the violation, include exact path from files[].path, and specify the line number from files[].numbered. Be detailed in your analysis - check for multiple violations per rule and multiple rules per file. Output JSON: {overall:{summary:string, key_issues:[{rule_id:string, reason:string, path:string, line:number}]}}. No markdown."
                },
                { "role":"user", "content": $content }
              ]
            }')
          RESP=$(curl -sS https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$REQ")

          jq -r '.choices[0].message.content' <<< "$RESP" > /tmp/review_raw.json || true
          if ! [ -s /tmp/review_raw.json ]; then
            echo "OpenAI returned empty or invalid JSON:"
            echo "$RESP"
            exit 1
          fi

          # Normalize and keep only issues that reference a real rule file
          jq --slurpfile allow /tmp/rules_index.json '
            .overall as $o
            | {
                overall: {
                  summary: ($o.summary // ""),
                  key_issues: (
                    ($o.key_issues // [])
                    | map({
                        rule_id: (.rule_id // ""),
                        reason: (.reason // ""),
                        path: (.path // ""),
                        line: ((.line // 0) | tonumber)
                      })
                    | map(select(
                        (.rule_id|length)>0 and
                        (.path|length)>0 and
                        ((.line|tonumber)>0) and
                        (.rule_id as $r | ($allow[0] | index($r)))
                      ))
                  )
                }
              }
          ' /tmp/review_raw.json > /tmp/review.json

          echo "Normalized review JSON:"
          cat /tmp/review.json

      - name: Validate issues have real rule_id, path, line
        run: |
          set -e
          jq -e '
            (.overall.key_issues | type) == "array"
            and ((.overall.key_issues // []) | all(
              .rule_id and (.rule_id|length>0) and
              .path and (.path|length>0) and
              (.line|tonumber)>0
            ))
          ' /tmp/review.json >/dev/null || {
            echo "Validation failed. Review JSON follows:"
            cat /tmp/review.json
            exit 1
          }

      - name: Compute grade locally
        id: score
        run: |
          set -e
          COUNT=$(jq -r '(.overall.key_issues // []) | length' /tmp/review.json)
          if [ "$COUNT" -eq 0 ]; then GRADE="‚úÖ excellent";
          elif [ "$COUNT" -le 2 ]; then GRADE="üëç good";
          elif [ "$COUNT" -le 5 ]; then GRADE="‚ö†Ô∏è needs improvement";
          else GRADE="‚ùå requires attention"; fi
          echo "count=$COUNT" >> "$GITHUB_OUTPUT"
          echo "grade=$GRADE" >> "$GITHUB_OUTPUT"

      - name: Prepare Slack message
        id: prep
        run: |
          set -e
          SHA="${{ steps.info.outputs.sha }}"
          SHORT=${SHA:0:7}
          AUTHOR="${{ steps.info.outputs.actor }}"
          REPO="${{ steps.info.outputs.repo }}"
          COMMIT_URL="https://github.com/$REPO/commit/$SHA"

          GRADE="${{ steps.score.outputs.grade }}"
          COUNT="${{ steps.score.outputs.count }}"

          ISSUES=$(jq -r '
            (.overall.key_issues // [])
            | to_entries
            | map("‚Ä¢ **\(.value.rule_id)** `(Line \(.value.line))`: \(.value.reason)\n  üìÑ `\(.value.path)`")
            | join("\n\n")
          ' /tmp/review.json)

          {
            echo "üîç *Commit Review Report*"
            echo ""
            echo "üë§ *Author:* $AUTHOR"
            echo "üìù *Commit:* <$COMMIT_URL|$SHORT>"
            echo "üìä *Grade:* $GRADE"
            echo ""
            if [ "$COUNT" -gt 0 ]; then
              echo "‚ö†Ô∏è *Issues Found ($COUNT):*"
              echo ""
              echo "$ISSUES"
            else
              echo "‚ú® *No issues found!* All code follows the established rules."
            fi
          } > /tmp/slack.txt

          echo "Slack message preview:"
          cat /tmp/slack.txt

      - name: Post to Slack
        if: success()
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          CHANNEL_ID: ${{ secrets.CHANNEL_ID }}
        run: |
          set -euo pipefail
          if [ -z "${SLACK_BOT_TOKEN:-}" ]; then
            echo "SLACK_BOT_TOKEN is empty"
            exit 1
          fi

          # Post message
          RESP="$(curl -sS -X POST \
            -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
            -H "Content-type: application/json; charset=utf-8" \
            --data "$(jq -n --arg channel "$CHANNEL_ID" --arg text "$(cat /tmp/slack.txt)" '{channel: $channel, text: $text}')" \
            https://slack.com/api/chat.postMessage)"

          echo "$RESP" > /tmp/slack_resp.json

          # Validate Slack response
          if ! jq -e '.ok == true' /tmp/slack_resp.json >/dev/null; then
            echo "Slack API error:"
            cat /tmp/slack_resp.json
            exit 1
          fi
