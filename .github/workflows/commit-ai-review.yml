name: Commit AI Review (Rules Only)

on:
  workflow_call:
    secrets:
      CHANNEL_ID:
        required: true
        description: "Slack channel ID to post the review"
      OPENAI_API_KEY:
        required: true
        description: "OpenAI API key"
      SLACK_BOT_TOKEN:
        required: true
        description: "Slack bot token with chat:write"

permissions:
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  review-latest-commit:
    runs-on: ubuntu-latest
    steps:
      - name: Check if Shopify bot commit
        id: bot_check
        run: |
          ACTOR="${{ github.actor }}"
          if [ "$ACTOR" = "shopify[bot]" ]; then
            echo "skip=true" >> "$GITHUB_OUTPUT"
            echo "Skipping review for Shopify bot commit by: $ACTOR"
          else
            echo "skip=false" >> "$GITHUB_OUTPUT"
            echo "Proceeding with review for commit by: $ACTOR"
          fi

      - name: Guard caller org
        if: steps.bot_check.outputs.skip != 'true'
        run: |
          ALLOWED_ORGS=("EcomExperts-io" "mountain-house-shopify" "mindbodygreen")
          CALLER_ORG="${{ github.repository_owner }}"
          
          # Check if caller org is in allowed list
          for org in "${ALLOWED_ORGS[@]}"; do
            if [ "$CALLER_ORG" = "$org" ]; then
              echo "Access granted for: $CALLER_ORG"
              exit 0
            fi
          done
          
          echo "Unauthorized caller: $CALLER_ORG"
          echo "Allowed organizations: ${ALLOWED_ORGS[*]}"
          exit 1

      - name: Checkout caller repo
        if: steps.bot_check.outputs.skip != 'true'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install jq
        if: steps.bot_check.outputs.skip != 'true'
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Gather commit data
        if: steps.bot_check.outputs.skip != 'true'
        id: info
        run: |
          set -e
          SHA="${GITHUB_SHA}"
          REPO="${GITHUB_REPOSITORY}"
          ACTOR="${GITHUB_ACTOR}"
          echo "sha=$SHA" >> "$GITHUB_OUTPUT"
          echo "actor=$ACTOR" >> "$GITHUB_OUTPUT"
          echo "repo=$REPO" >> "$GITHUB_OUTPUT"
          # latest commit only
          git diff-tree --no-commit-id --name-status -r "$SHA" | tr -d '\r' > /tmp/changed.txt

      - name: Checkout central rules repo
        if: steps.bot_check.outputs.skip != 'true'
        uses: actions/checkout@v4
        with:
          repository: EcomExperts-io/org-ci-workflows
          ref: Main
          path: rules-src
          fetch-depth: 1

      - name: Load rules from .cursor/rules
        if: steps.bot_check.outputs.skip != 'true'
        id: rules
        run: |
          set -e
          PRIMARY_DIR="rules-src/.cursor/rules"
          FALLBACK_DIR="rules-src/cursor/rules"
          if [ -d "$PRIMARY_DIR" ]; then
            RULE_DIR="$PRIMARY_DIR"
          elif [ -d "$FALLBACK_DIR" ]; then
            RULE_DIR="$FALLBACK_DIR"
          else
            echo "No rules directory found. Expected $PRIMARY_DIR or $FALLBACK_DIR" >&2
            exit 1
          fi
          echo "rule_dir=$RULE_DIR" >> "$GITHUB_OUTPUT"

          jq -n '[]' > /tmp/rules.json
          while IFS= read -r -d '' file; do
            CONTENT=$(sed 's/\\/\\\\/g; s/"/\\"/g' "$file" | awk '{printf "%s\\n",$0}')
            
            # Extract metadata from frontmatter if it exists
            ALWAYS_APPLY="false"
            GLOBS=""
            if head -n 1 "$file" | grep -q "^---"; then
              # Parse frontmatter for alwaysApply and globs
              FRONTMATTER=$(sed -n '2,/^---/p' "$file" | sed '$d')
              if echo "$FRONTMATTER" | grep -q "alwaysApply: *true"; then
                ALWAYS_APPLY="true"
              fi
              GLOBS=$(echo "$FRONTMATTER" | grep "^globs:" | sed 's/globs: *//' | tr '\n' ',' | sed 's/,$//')
            fi
            
            jq --arg name "$(basename "$file")" \
               --arg path "$file" \
               --arg text "$CONTENT" \
               --arg always_apply "$ALWAYS_APPLY" \
               --arg globs "$GLOBS" \
               '. += [{"name":$name,"path":$path,"text":$text,"always_apply":($always_apply=="true"),"globs":$globs}]' \
               /tmp/rules.json > /tmp/rules.tmp && mv /tmp/rules.tmp /tmp/rules.json
          done < <(find "$RULE_DIR" -type f -maxdepth 5 -print0 | sort -z)

          # Build an index of allowed rule_ids (filenames without extension)
          jq -r '.[].name | sub("\\.mdc$"; "")' /tmp/rules.json | jq -R -s 'split("\n") | map(select(length>0))' > /tmp/rules_index.json

          echo "Loaded rules:"
          jq 'length as $n | "count=\($n)"' /tmp/rules.json
          echo "Rule names:"
          jq -r '.[]' /tmp/rules_index.json | head -50

      - name: Build diff content for changed files only
        if: steps.bot_check.outputs.skip != 'true'
        run: |
          set -e
          SHA="${GITHUB_SHA}"
          jq -n '{files:[]}' > /tmp/files.json
          
          while IFS=$'\t' read -r status path; do
            case "$path" in
              *.liquid|*.js|*.css)
                if [ -f "$path" ]; then
                  echo "Processing $status file: $path"
                  
                  # Get the actual diff for this file (with context lines for better understanding)
                  if [ "$status" = "A" ]; then
                    # New file - show entire content but mark as new
                    DIFF_CONTENT="=== NEW FILE: $path ===\n$(cat "$path" | nl -ba -w1 -s': ')"
                  elif [ "$status" = "D" ]; then
                    # Deleted file - skip review (no point reviewing deleted code)
                    echo "Skipping deleted file: $path"
                    continue
                  else
                    # Modified file - show only the diff with context
                    DIFF_CONTENT=$(git show --no-merges --format="" "$SHA" -- "$path" 2>/dev/null || echo "Error getting diff for $path")
                    if [ "$DIFF_CONTENT" = "Error getting diff for $path" ]; then
                      echo "Warning: Could not get diff for $path, using full file content"
                      DIFF_CONTENT="=== FULL FILE (diff unavailable): $path ===\n$(cat "$path" | nl -ba -w1 -s': ')"
                    else
                      DIFF_CONTENT="=== CHANGES IN: $path ===\n$DIFF_CONTENT"
                    fi
                  fi
                  
                  # Escape for JSON
                  ESCAPED_DIFF=$(echo "$DIFF_CONTENT" | sed 's/\\/\\\\/g; s/"/\\"/g' | awk '{printf "%s\\n",$0}')
                  
                  # Determine applicable rules for this file
                  APPLICABLE_RULES=$(jq -c --arg filepath "$path" '
                    map(select(
                      .always_apply == true or
                      (.globs != "" and (
                        .globs | split(",") | map(gsub(" "; "")) | map(select(length > 0)) |
                        any(. as $glob | $filepath | test($glob | gsub("\\*"; ".*") | gsub("\\?"; ".")))
                      ))
                    )) | map(.name | sub("\\.mdc$"; ""))
                  ' /tmp/rules.json)
                  
                  jq --arg p "$path" --arg d "$ESCAPED_DIFF" --arg s "$status" --argjson rules "$APPLICABLE_RULES" \
                     '.files += [{"path":$p,"diff_content":$d,"status":$s,"applicable_rules":$rules}]' \
                     /tmp/files.json > /tmp/files.tmp && mv /tmp/files.tmp /tmp/files.json
                fi
              ;;
            esac
          done < /tmp/changed.txt

          echo "Changed files with diffs captured:"
          jq '.files | length as $n | "count=\($n)"' /tmp/files.json
          echo "Files being reviewed:"
          jq -r '.files[] | "- \(.path) (\(.status))"' /tmp/files.json

      - name: Build AI input (rules and diffs)
        if: steps.bot_check.outputs.skip != 'true'
        run: |
          set -e
          RULES=$(cat /tmp/rules.json)
          FILES=$(cat /tmp/files.json)
          printf '{"rules":%s,"files":%s}' "$RULES" "$FILES" > /tmp/ai_input.json
          echo "ai_input.json sizes:"
          echo "rules.json bytes: $(wc -c < /tmp/rules.json)"
          echo "files.json bytes: $(wc -c < /tmp/files.json)"

      - name: Call OpenAI strictly by rules
        if: steps.bot_check.outputs.skip != 'true'
        id: ai
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set -e
          jq -c -n \
            --slurpfile content /tmp/ai_input.json \
            '{
              model:"gpt-4o",
              response_format:{type:"json_object"},
              temperature:0,
              messages:[
                {
                  "role":"system",
                  "content": "You are a comprehensive code reviewer that evaluates ONLY THE CHANGES made in a commit against coding standards. For each file, you will receive either: 1) A git diff showing only the changed lines (for modified files), 2) Full content (for new files), or 3) Nothing (for deleted files - skip these). Focus ONLY on the added/modified lines (lines starting with + in diffs). Check ALL applicable rules from the rules[] array. Rules apply based on: 1) alwaysApply: true in metadata, or 2) file path matching globs patterns in metadata. Look for ALL violations of the provided rules in the CHANGED CODE ONLY - be thorough and comprehensive. For each violation found: use rule_id as the rule filename without .mdc extension (e.g., \"rules-of-engagement\" not \"rules-of-engagement.mdc\"), provide specific reason explaining the violation, include exact path from files[].path, and specify the line number from the diff context (look for line numbers in diff headers like @@). Focus on NEW or CHANGED code only, not existing code that wasn't modified. Output JSON: {overall:{summary:string, key_issues:[{rule_id:string, reason:string, path:string, line:number}]}}. No markdown."
                },
                { "role":"user", "content": ($content[0] | tostring) }
              ]
            }' > /tmp/openai_request.json
          RESP=$(curl -sS https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @/tmp/openai_request.json)

          jq -r '.choices[0].message.content' <<< "$RESP" > /tmp/review_raw.json || true
          if ! [ -s /tmp/review_raw.json ]; then
            echo "OpenAI returned empty or invalid JSON:"
            echo "$RESP"
            exit 1
          fi

          # Normalize and keep only issues that reference a real rule file
          jq --slurpfile allow /tmp/rules_index.json '
            .overall as $o
            | {
                overall: {
                  summary: ($o.summary // ""),
                  key_issues: (
                    ($o.key_issues // [])
                    | map({
                        rule_id: (.rule_id // ""),
                        reason: (.reason // ""),
                        path: (.path // ""),
                        line: ((.line // 0) | tonumber)
                      })
                    | map(select(
                        (.rule_id|length)>0 and
                        (.path|length)>0 and
                        ((.line|tonumber)>0) and
                        (.rule_id as $r | ($allow[0] | index($r)))
                      ))
                  )
                }
              }
          ' /tmp/review_raw.json > /tmp/review.json

          echo "Normalized review JSON:"
          cat /tmp/review.json

      - name: Validate issues have real rule_id, path, line
        if: steps.bot_check.outputs.skip != 'true'
        run: |
          set -e
          jq -e '
            (.overall.key_issues | type) == "array"
            and ((.overall.key_issues // []) | all(
              .rule_id and (.rule_id|length>0) and
              .path and (.path|length>0) and
              (.line|tonumber)>0
            ))
          ' /tmp/review.json >/dev/null || {
            echo "Validation failed. Review JSON follows:"
            cat /tmp/review.json
            exit 1
          }

      - name: Compute grade locally
        if: steps.bot_check.outputs.skip != 'true'
        id: score
        run: |
          set -e
          COUNT=$(jq -r '(.overall.key_issues // []) | length' /tmp/review.json)
          if [ "$COUNT" -eq 0 ]; then GRADE="✅ excellent";
          elif [ "$COUNT" -le 2 ]; then GRADE="👍 good";
          elif [ "$COUNT" -le 5 ]; then GRADE="⚠️ needs improvement";
          else GRADE="❌ requires attention"; fi
          echo "count=$COUNT" >> "$GITHUB_OUTPUT"
          echo "grade=$GRADE" >> "$GITHUB_OUTPUT"

      - name: Prepare Slack messages
        if: steps.bot_check.outputs.skip != 'true'
        id: prep
        run: |
          set -e
          SHA="${{ steps.info.outputs.sha }}"
          SHORT=${SHA:0:7}
          AUTHOR="${{ steps.info.outputs.actor }}"
          REPO="${{ steps.info.outputs.repo }}"
          COMMIT_URL="https://github.com/$REPO/commit/$SHA"

          GRADE="${{ steps.score.outputs.grade }}"
          COUNT="${{ steps.score.outputs.count }}"

          # Main message (summary only)
          {
            echo "*Commit Review Report*"
            echo ""
            echo "*Author:* $AUTHOR"
            echo "*Commit:* <$COMMIT_URL|$SHORT>"
            echo "*Grade:* $GRADE"
            echo ""
            if [ "$COUNT" -gt 0 ]; then
              echo "*Issues Found:* $COUNT (details in thread)"
            else
              echo "*No issues found!* All code follows the established rules."
            fi
          } > /tmp/slack_main.txt

          # Thread reply with detailed issues (only if there are issues)
          if [ "$COUNT" -gt 0 ]; then
            ISSUES=$(jq -r '
              (.overall.key_issues // [])
              | to_entries
              | map("\(.key + 1). *\(.value.rule_id):* \(.value.reason) — `\(.value.path)` - `Line \(.value.line)`")
              | join("\n\n")
            ' /tmp/review.json)
            
            {
              echo "*Detailed Issues:*"
              echo ""
              echo "$ISSUES"
            } > /tmp/slack_thread.txt
            
            echo "has_issues=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_issues=false" >> "$GITHUB_OUTPUT"
          fi

          echo "Main Slack message preview:"
          cat /tmp/slack_main.txt
          
          if [ "$COUNT" -gt 0 ]; then
            echo ""
            echo "Thread reply preview:"
            cat /tmp/slack_thread.txt
          fi

      - name: Post main message to Slack
        if: success() && steps.bot_check.outputs.skip != 'true'
        id: slack_main
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          CHANNEL_ID: ${{ secrets.CHANNEL_ID }}
        run: |
          set -euo pipefail
          if [ -z "${SLACK_BOT_TOKEN:-}" ]; then
            echo "SLACK_BOT_TOKEN is empty"
            exit 1
          fi

          # Post main message
          RESP="$(curl -sS -X POST \
            -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
            -H "Content-type: application/json; charset=utf-8" \
            --data "$(jq -n --arg channel "$CHANNEL_ID" --arg text "$(cat /tmp/slack_main.txt)" '{channel: $channel, text: $text}')" \
            https://slack.com/api/chat.postMessage)"

          echo "$RESP" > /tmp/slack_main_resp.json

          # Validate Slack response
          if ! jq -e '.ok == true' /tmp/slack_main_resp.json >/dev/null; then
            echo "Slack API error:"
            cat /tmp/slack_main_resp.json
            exit 1
          fi

          # Extract timestamp for threading
          TIMESTAMP=$(jq -r '.ts' /tmp/slack_main_resp.json)
          echo "timestamp=$TIMESTAMP" >> "$GITHUB_OUTPUT"
          echo "Main message posted with timestamp: $TIMESTAMP"

      - name: Post detailed issues as thread reply
        if: success() && steps.bot_check.outputs.skip != 'true' && steps.prep.outputs.has_issues == 'true'
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          CHANNEL_ID: ${{ secrets.CHANNEL_ID }}
        run: |
          set -euo pipefail
          TIMESTAMP="${{ steps.slack_main.outputs.timestamp }}"
          
          if [ -z "$TIMESTAMP" ]; then
            echo "No timestamp available for threading"
            exit 1
          fi

          # Post thread reply with detailed issues
          RESP="$(curl -sS -X POST \
            -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
            -H "Content-type: application/json; charset=utf-8" \
            --data "$(jq -n --arg channel "$CHANNEL_ID" --arg text "$(cat /tmp/slack_thread.txt)" --arg thread_ts "$TIMESTAMP" '{channel: $channel, text: $text, thread_ts: $thread_ts}')" \
            https://slack.com/api/chat.postMessage)"

          echo "$RESP" > /tmp/slack_thread_resp.json

          # Validate Slack response
          if ! jq -e '.ok == true' /tmp/slack_thread_resp.json >/dev/null; then
            echo "Slack thread reply API error:"
            cat /tmp/slack_thread_resp.json
            exit 1
          fi

          echo "Thread reply posted successfully"
