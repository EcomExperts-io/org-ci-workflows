name: Commit AI Review

on:
  workflow_call:
    secrets:
      CHANNEL_ID:
        required: true
        description: "Slack channel ID to post the review"
      OPENAI_KEY:
        required: true
        description: "OpenAI API key"
      SLACK_BOT_TOKEN:
        required: true
        description: "Slack bot token with chat:write"

permissions:
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  review-latest-commit:
    runs-on: ubuntu-latest
    steps:
      # Optional guard so only your org can call this workflow
      - name: Guard caller org
        run: |
          if [ "${{ github.repository_owner }}" != "EcomExperts-io" ]; then
            echo "Unauthorized caller: ${{ github.repository_owner }}"
            exit 1
          fi

      - name: Checkout caller repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Gather commit data
        id: info
        run: |
          set -e
          SHA="${GITHUB_SHA}"
          REPO="${GITHUB_REPOSITORY}"
          ACTOR="${GITHUB_ACTOR}"
          echo "sha=$SHA" >> "$GITHUB_OUTPUT"
          echo "actor=$ACTOR" >> "$GITHUB_OUTPUT"
          echo "repo=$REPO" >> "$GITHUB_OUTPUT"
          git show --no-color --unified=3 "$SHA" > /tmp/diff.patch
          git diff-tree --no-commit-id --name-status -r "$SHA" | tr -d '\r' > /tmp/changed.txt

      # Fetch rules from the central repo .cursor/rules
      # If org-ci-workflows is public, no token is needed
      - name: Checkout central rules repo
        uses: actions/checkout@v4
        with:
          repository: EcomExperts-io/org-ci-workflows
          ref: Main        # change to Main if your default branch uses capital M
          path: rules-src
          fetch-depth: 1

      - name: Load rules from central .cursor/rules
        run: |
          set -e
          RULE_DIR="rules-src/.cursor/rules"
          jq -n '[]' > /tmp/rules.json
          if [ -d "$RULE_DIR" ]; then
            while IFS= read -r -d '' file; do
              CONTENT=$(sed 's/\\/\\\\/g; s/"/\\"/g' "$file" | awk '{printf "%s\\n",$0}')
              jq --arg name "$(basename "$file")" \
                 --arg path "$file" \
                 --arg text "$CONTENT" \
                 '. += [{"name":$name,"path":$path,"text":$text}]' \
                 /tmp/rules.json > /tmp/rules.tmp && mv /tmp/rules.tmp /tmp/rules.json
            done < <(find "$RULE_DIR" -type f -maxdepth 5 -print0 | sort -z)
          else
            echo "Rules directory not found at $RULE_DIR" >&2
            exit 1
          fi

      - name: Build numbered files bundle
        run: |
          set -e
          jq -n '{files:[]}' > /tmp/files.json
          # Capture a broader set of web/theme files
          while IFS=$'\t' read -r status path; do
            case "$path" in
              *.liquid|*.js|*.ts|*.css|*.scss|*.json)
                if [ -f "$path" ]; then
                  NUMBERED=$(nl -ba -w1 -s': ' "$path" | sed 's/\\/\\\\/g; s/"/\\"/g' | awk '{printf "%s\\n",$0}')
                  jq --arg p "$path" --arg n "$NUMBERED" \
                     '.files += [{"path":$p,"numbered":$n}]' \
                     /tmp/files.json > /tmp/files.tmp && mv /tmp/files.tmp /tmp/files.json
                fi
              ;;
            esac
          done < /tmp/changed.txt

      - name: Build AI input
        run: |
          set -e
          RULES=$(cat /tmp/rules.json)
          DIFF=$(sed 's/\\/\\\\/g; s/"/\\"/g' /tmp/diff.patch | tr -d '\r' | awk '{printf "%s\\n",$0}')
          FILES=$(cat /tmp/files.json)
          printf '{"rules":%s,"diff":"%s","files":%s}' "$RULES" "$DIFF" "$FILES" > /tmp/ai_input.json
          # Quick visibility for debugging
          echo "Prepared AI input sizes:"
          echo "rules.json bytes: $(wc -c < /tmp/rules.json)"
          echo "diff.patch bytes: $(wc -c < /tmp/diff.patch)"
          echo "files.json bytes: $(wc -c < /tmp/files.json)"

      # Structured JSON response for robust parsing
      - name: Call OpenAI for review
        id: ai
        env:
          OPENAI_KEY: ${{ secrets.OPENAI_KEY }}
        run: |
          set -e
          REQ=$(jq -c -n \
            --arg content "$(cat /tmp/ai_input.json)" \
            '{
              model:"gpt-4o-mini",
              response_format:{type:"json_object"},
              temperature:0,
              messages:[
                {
                  "role":"system",
                  "content": "You are an automated code reviewer for Shopify themes. You MUST output strict JSON only. Schema: {overall:{grade:string, summary:string, key_issues:[{rule_id:string, reason:string, path:string, line:number}]}}. Only include an issue if you can point to an exact repository-relative file path and a single 1-based line number. Rules are provided in rules[] with fields {name, path, text}. Treat inline <style>/<script> inside .liquid as CSS/JS. Numbered file contents are in files[] items with fields {path, numbered} where numbered looks like \"12: const x = 1\". Use those numbers. Grade must be one of: best, good, average, poor. If unsure, omit the issue rather than guessing."
                },
                { "role":"user", "content": $content }
              ]
            }')
          RESP=$(curl -sS https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_KEY" \
            -H "Content-Type: application/json" \
            -d "$REQ")

          # Save raw content then coerce to the expected shape
          jq -r '.choices[0].message.content' <<< "$RESP" > /tmp/review_raw.json || true
          if ! [ -s /tmp/review_raw.json ]; then
            echo "OpenAI returned an empty response or invalid JSON. Full API payload follows:"
            echo "$RESP"
            exit 1
          fi

          jq '
            .overall as $o
            | {
                overall: {
                  grade: (($o.grade // "average") | tostring),
                  summary: ($o.summary // ""),
                  key_issues: (
                    ($o.key_issues // [])
                    | map({
                        rule_id: (.rule_id // "RULE"),
                        reason: (.reason // ""),
                        path: (.path // ""),
                        line: ((.line // 0) | tonumber)
                      })
                    | map(select((.path|length) > 0 and (.line|tonumber) > 0))
                  )
                }
              }
          ' /tmp/review_raw.json > /tmp/review.json

          echo "Normalized review JSON:"
          cat /tmp/review.json

      - name: Validate issues have path and line
        run: |
          set -e
          jq -e '
            (.overall.key_issues | type) == "array"
            and ((.overall.key_issues // []) | all(.path and (.path|length>0) and (.line|tonumber)>0))
          ' /tmp/review.json >/dev/null || {
            echo "AI output failed validation. Review JSON below:"
            cat /tmp/review.json
            exit 1
          }

      - name: Prepare Slack message
        id: prep
        run: |
          set -e
          SHA="${{ steps.info.outputs.sha }}"
          SHORT=${SHA:0:7}
          AUTHOR="${{ steps.info.outputs.actor }}"
          REPO="${{ steps.info.outputs.repo }}"
          COMMIT_URL="https://github.com/$REPO/commit/$SHA"

          GRADE=$(jq -r '.overall.grade' /tmp/review.json)
          COUNT=$(jq -r '(.overall.key_issues // []) | length' /tmp/review.json)

          ISSUES=$(jq -r '
            (.overall.key_issues // [])
            | to_entries
            | map("\(.key+1). \(.value.rule_id): \(.value.reason) in `\(.value.path)` Line: `\(.value.line)`")
            | join("\n")
          ' /tmp/review.json)

          {
            echo "*Commit Review*"
            echo "*Author:* $AUTHOR"
            echo "*Commit:* <$COMMIT_URL|$SHORT>"
            echo "*Grade:* $GRADE"
            echo "*Issues ($COUNT):*"
            if [ -n "$ISSUES" ]; then
              echo "$ISSUES"
            else
              echo "None"
            fi
          } > /tmp/slack.txt

          echo "Slack message preview:"
          cat /tmp/slack.txt

      - name: Post to Slack
        if: success()
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          CHANNEL_ID: ${{ secrets.CHANNEL_ID }}
        run: |
          set -e
          if [ -z "$SLACK_BOT_TOKEN" ]; then
            echo "SLACK_BOT_TOKEN is empty. Ensure it is passed from the caller or use secrets: inherit."
            exit 1
          fi
          curl -sS -X POST \
            -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
            -H "Content-type: application/json; charset=utf-8" \
            --data "$(jq -n --arg channel "$CHANNEL_ID" --arg text "$(cat /tmp/slack.txt)" '{channel: $channel, text: $text}')" \
            https://slack.com/api/chat.postMessage | tee /tmp/slack_resp.json

          if ! jq -e '.ok == true' /tmp/slack_resp.json >/dev/null; then
            echo "Slack API returned an error:"
            cat /tmp/slack_resp.json
            exit 1
          fi
