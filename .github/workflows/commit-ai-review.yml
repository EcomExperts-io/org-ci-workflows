name: Commit AI Review (Rules Only)

on:
  workflow_call:
    secrets:
      CHANNEL_ID:
        required: true
        description: "Slack channel ID to post the review"
      OPENAI_KEY:
        required: true
        description: "OpenAI API key"
      SLACK_BOT_TOKEN:
        required: true
        description: "Slack bot token with chat:write"

permissions:
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  review-latest-commit:
    runs-on: ubuntu-latest
    steps:
      - name: Guard caller org
        run: |
          if [ "${{ github.repository_owner }}" != "EcomExperts-io" ]; then
            echo "Unauthorized caller: ${{ github.repository_owner }}"
            exit 1
          fi

      - name: Checkout caller repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Gather commit data
        id: info
        run: |
          set -e
          SHA="${GITHUB_SHA}"
          REPO="${GITHUB_REPOSITORY}"
          ACTOR="${GITHUB_ACTOR}"
          echo "sha=$SHA" >> "$GITHUB_OUTPUT"
          echo "actor=$ACTOR" >> "$GITHUB_OUTPUT"
          echo "repo=$REPO" >> "$GITHUB_OUTPUT"
          # latest commit only
          git diff-tree --no-commit-id --name-status -r "$SHA" | tr -d '\r' > /tmp/changed.txt

      - name: Checkout central rules repo
        uses: actions/checkout@v4
        with:
          repository: EcomExperts-io/org-ci-workflows
          ref: Main        # change to Main if your default branch uses capital M
          path: rules-src
          fetch-depth: 1

      - name: Load rules from cursor_rules or .cursor/rules
        id: rules
        run: |
          set -e
          PRIMARY_DIR="rules-src/cursor_rules"
          FALLBACK_DIR="rules-src/.cursor/rules"
          if [ -d "$PRIMARY_DIR" ]; then
            RULE_DIR="$PRIMARY_DIR"
          elif [ -d "$FALLBACK_DIR" ]; then
            RULE_DIR="$FALLBACK_DIR"
          else
            echo "No rules directory found. Expected $PRIMARY_DIR or $FALLBACK_DIR" >&2
            exit 1
          fi
          echo "rule_dir=$RULE_DIR" >> "$GITHUB_OUTPUT"

          jq -n '[]' > /tmp/rules.json
          while IFS= read -r -d '' file; do
            CONTENT=$(sed 's/\\/\\\\/g; s/"/\\"/g' "$file" | awk '{printf "%s\\n",$0}')
            jq --arg name "$(basename "$file")" \
               --arg path "$file" \
               --arg text "$CONTENT" \
               '. += [{"name":$name,"path":$path,"text":$text}]' \
               /tmp/rules.json > /tmp/rules.tmp && mv /tmp/rules.tmp /tmp/rules.json
          done < <(find "$RULE_DIR" -type f -maxdepth 5 -print0 | sort -z)

          # Build an index of allowed rule_ids (filenames)
          jq -r '.[].name' /tmp/rules.json | jq -R -s 'split("\n") | map(select(length>0))' > /tmp/rules_index.json

          echo "Loaded rules:"
          jq 'length as $n | "count=\($n)"' /tmp/rules.json
          echo "Rule names:"
          jq -r '.[]' /tmp/rules_index.json | head -50

      - name: Build numbered files bundle from latest commit only
        run: |
          set -e
          jq -n '{files:[]}' > /tmp/files.json
          while IFS=$'\t' read -r status path; do
            case "$path" in
              *.liquid|*.json|*.js|*.mjs|*.cjs|*.ts|*.tsx|*.jsx|*.css|*.scss|*.sass|*.vue|*.html|*.svg|*.yml|*.yaml|*.md)
                if [ -f "$path" ]; then
                  NUMBERED=$(nl -ba -w1 -s': ' "$path" | sed 's/\\/\\\\/g; s/"/\\"/g' | awk '{printf "%s\\n",$0}')
                  jq --arg p "$path" --arg n "$NUMBERED" \
                     '.files += [{"path":$p,"numbered":$n}]' \
                     /tmp/files.json > /tmp/files.tmp && mv /tmp/files.tmp /tmp/files.json
                fi
              ;;
            esac
          done < /tmp/changed.txt

          echo "Changed files captured:"
          jq '.files | length as $n | "count=\($n)"' /tmp/files.json

      - name: Build AI input (rules only, no diff)
        run: |
          set -e
          RULES=$(cat /tmp/rules.json)
          FILES=$(cat /tmp/files.json)
          printf '{"rules":%s,"files":%s}' "$RULES" "$FILES" > /tmp/ai_input.json
          echo "ai_input.json sizes:"
          echo "rules.json bytes: $(wc -c < /tmp/rules.json)"
          echo "files.json bytes: $(wc -c < /tmp/files.json)"

      - name: Call OpenAI strictly by rules
        id: ai
        env:
          OPENAI_KEY: ${{ secrets.OPENAI_KEY }}
        run: |
          set -e
          REQ=$(jq -c -n \
            --arg content "$(cat /tmp/ai_input.json)" \
            '{
              model:"gpt-4o",
              response_format:{type:"json_object"},
              temperature:0,
              messages:[
                {
                  "role":"system",
                  "content": "You are a rules-only static checker. Only evaluate the provided files[] against the provided rules[]. Do not apply any additional heuristics or best practices. Do not invent rules. Report an issue only when it is an explicit violation of a rule from rules[]. Each issue must reference an existing rule_id that equals the rule file name (rules[].name), and must include an exact repository-relative path from files[].path and a single 1-based line number taken from files[].numbered. If you are not certain of a violation, omit it. Output strict JSON only with schema: {overall:{summary:string, key_issues:[{rule_id:string, reason:string, path:string, line:number}]}}. No markdown."
                },
                { "role":"user", "content": $content }
              ]
            }')
          RESP=$(curl -sS https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_KEY" \
            -H "Content-Type: application/json" \
            -d "$REQ")

          jq -r '.choices[0].message.content' <<< "$RESP" > /tmp/review_raw.json || true
          if ! [ -s /tmp/review_raw.json ]; then
            echo "OpenAI returned empty or invalid JSON:"
            echo "$RESP"
            exit 1
          fi

          # Normalize and keep only issues that reference a real rule file
          jq --slurpfile allow /tmp/rules_index.json '
            .overall as $o
            | {
                overall: {
                  summary: ($o.summary // ""),
                  key_issues: (
                    ($o.key_issues // [])
                    | map({
                        rule_id: (.rule_id // ""),
                        reason: (.reason // ""),
                        path: (.path // ""),
                        line: ((.line // 0) | tonumber)
                      })
                    | map(select(
                        (.rule_id|length)>0 and
                        (.path|length)>0 and
                        ((.line|tonumber)>0) and
                        (.rule_id as $r | ($allow[0] | index($r)))
                      ))
                  )
                }
              }
          ' /tmp/review_raw.json > /tmp/review.json

          echo "Normalized review JSON:"
          cat /tmp/review.json

      - name: Validate issues have real rule_id, path, line
        run: |
          set -e
          jq -e '
            (.overall.key_issues | type) == "array"
            and ((.overall.key_issues // []) | all(
              .rule_id and (.rule_id|length>0) and
              .path and (.path|length>0) and
              (.line|tonumber)>0
            ))
          ' /tmp/review.json >/dev/null || {
            echo "Validation failed. Review JSON follows:"
            cat /tmp/review.json
            exit 1
          }

      - name: Compute grade locally
        id: score
        run: |
          set -e
          COUNT=$(jq -r '(.overall.key_issues // []) | length' /tmp/review.json)
          if [ "$COUNT" -eq 0 ]; then GRADE="best";
          elif [ "$COUNT" -le 2 ]; then GRADE="good";
          elif [ "$COUNT" -le 5 ]; then GRADE="average";
          else GRADE="poor"; fi
          echo "count=$COUNT" >> "$GITHUB_OUTPUT"
          echo "grade=$GRADE" >> "$GITHUB_OUTPUT"

      - name: Prepare Slack message
        id: prep
        run: |
          set -e
          SHA="${{ steps.info.outputs.sha }}"
          SHORT=${SHA:0:7}
          AUTHOR="${{ steps.info.outputs.actor }}"
          REPO="${{ steps.info.outputs.repo }}"
          COMMIT_URL="https://github.com/$REPO/commit/$SHA"

          GRADE="${{ steps.score.outputs.grade }}"
          COUNT="${{ steps.score.outputs.count }}"

          ISSUES=$(jq -r '
            (.overall.key_issues // [])
            | to_entries
            | map("\(.key+1). \(.value.rule_id): \(.value.reason) in `\(.value.path)` Line: `\(.value.line)`")
            | join("\n")
          ' /tmp/review.json)

          {
            echo "*Commit Review*"
            echo "*Author:* $AUTHOR"
            echo "*Commit:* <$COMMIT_URL|$SHORT>"
            echo "*Grade:* $GRADE"
            echo "*Issues ($COUNT):*"
            if [ -n "$ISSUES" ]; then
              echo "$ISSUES"
            else
              echo "None"
            fi
          } > /tmp/slack.txt

          echo "Slack message preview:"
          cat /tmp/slack.txt

      - name: Post to Slack
        if: success()
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          CHANNEL_ID: ${{ secrets.CHANNEL_ID }}
        run: |
          set -euo pipefail
          if [ -z "${SLACK_BOT_TOKEN:-}" ]; then
            echo "SLACK_BOT_TOKEN is empty"
            exit 1
          fi

          # Post message
          RESP="$(curl -sS -X POST \
            -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
            -H "Content-type: application/json; charset=utf-8" \
            --data "$(jq -n --arg channel "$CHANNEL_ID" --arg text "$(cat /tmp/slack.txt)" '{channel: $channel, text: $text}')" \
            https://slack.com/api/chat.postMessage)"

          echo "$RESP" > /tmp/slack_resp.json

          # Validate Slack response
          if ! jq -e '.ok == true' /tmp/slack_resp.json >/dev/null; then
            echo "Slack API error:"
            cat /tmp/slack_resp.json
            exit 1
          fi
